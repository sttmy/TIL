# -*- coding: utf-8 -*-
"""230428 Jango2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19JuwWDTE7gSkltMoTfofzrDGYg0vmzuf
"""

점프 투 장고
https://wikidocs.net/book/4223

"""2-09 템플릿 상속"""

# 웹 표준 지키는 HTML 문서 작성

(pycharm)
templates > base.html파일 생성

{% load static %}
(...생략...)
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css %}">
    <link rel="stylesheet" type="text/css" href="{% static 'style.css %}">
    <title>Hello, pybo!</title>
</head>
<body>
    {% block content %}

    {% endblock %}    # body 안의 {% block content %} 와 {% endblock %} 템플릿 태그는 base.html을 상속한 템플릿에서 개별적으로 구현
</body>


(question_list.html)   # base.html과 연결
# {% load static %}~.... # 지우고
{% extends 'base.html' %}
{% block content %}
(.....생략 .....)
{% endblock %}


(question_detail.html) 
# {% load static %}~.... # 지우고
{% extends 'base.html' %}
{% block content %}
(.....생략 .....)
{% endblock %}

"""2-10 폼"""

# 질문 등록하기 버튼 만들기 ---------------------------
(question_list.html)

<a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
# btn btn-primary를 적용하면 버튼으로 보임
# pybo:question_create 별칭에 해당하는 url이 호출됨

# URL 매핑: views.question_create 함수 호출 --------------
(pybo > urls.py)

(...생략....)
urlpatterns = [
    (...생략....)
    path('question/create/', views.question_create, name='question_create'),
]

# 폼 만들기 : 페이지 요청 시 필요한 파라미터 관리 ---------------
(pybo > form.py) 생성

from django import forms
from pybo.models import Question

class QuestionForm(forms.ModelForm):    # ModelForm을 상속 (모델을 저장)
    class Meta:
        model = Question   # 사용할 모델
        fields = ['subject', 'content']    # QuestionForm에서 사용할 모델의 속성
        
# 뷰함수. QuestionForm 사용 ------------------
(pybo > views.py)
from .forms import QuestionForm

def question_create(request):
    form = QuestionForm()
    return render(request, 'pybo/question_form.html', {'form':form})

# 질문 등록할 수 있는 페이지 템플릿 만들기 ----------------------------
(templates > pybo > question_form.html) 생성

{% extends 'base.html' %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}   #form의 속성에 해당하는 것을 가져옴
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>

{% endblock %}

# 서버 재가동으로 확인 -----------------

# 질문 등록한 내용, 저장하기 ---------------------
(pybo > views.py) 수정

def question_create(request):
    if request.method == "POST":    
        form = QuestionForm(request.POST)
        if form.is_valid():    # 폼이 유효하다면
            question = form.save(commit = False)   # commit false: 임시저장
            question.create_date = timezone.now()  # 작성일시 설정
            # QuestionForm에는 subject, content 속성만 정의되어 있고 create_date속성은 정의하고 있지 않음
            # create_date 속성은 데이터 저장 시점에 생성해야 되므로 QuestionForm에 등록하여 사용하지 않음            
            question.save()                       # 데이터 실제로 저장
            return redirect('pybo:index')
    else:
        form = QuestionForm()
    context = {'form': form}
    return render(request, 'pybo/question_form.html', context)


# 질문목록 화면에서 '질문등록하기'버튼 클릭 >> GET방식으로 요청되어 question_create이 실행
<a href~> 링크 통한 페이지 요청시에는 GET방식이 사용됨
if .. else.. 구문에서 else구문을 실행

# 저장하기 버튼 클릭 >> POST방식으로 요청됨.

"""3장 파이보 서비스 개발

3-01 Navigation Bar
"""

# 네비게이션바: 모든 화면에 고정되어 있는 부트스트랩 컴포넌트. 메인페이지로 돌아갈 장치

(base.html)

<body>
<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{% url 'pybo:index' %}">Pybo</a>    # pybo 로고를 제일 왼쪽에
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>      # 로그인 링크 추가
                </li>
            </ul>
        </div>
    </div>
</nav>
{% blcok content%} ......~

# 현재 상태로는 창을 줄였을 때, 햄버거 메뉴 버튼이 생기지만 아무 변화가 없음
# 동적으로 동작할 수 있도록 bootstrap.min.js이 base.html파일에 포함되어야 함

# js파일 준비 ---------------------------------------------------
bootstrap.min.js파일을 static폴더 안에 넣어줌
https://jquery.com/download 3.4.1 ver download
https://code.jquery.com/jquery-3.4.1.min.js  static 폴더 안에 저장

# base.html 수정  ----------------------------
(base.html) 수정
    <!-- 네비게이션바 -->   # 네비게이션바 내용은 파일을 별도로 만들고 변경
    {% include "navbar.html" %}
    <!-- Bootstrap JS -->   # 부트스트랩 js 추가
    <script src = "{% static 'jquery-3.4.1.min.js' %}"></script>
    <script src = "{% static 'bootstrap.min.js' %}"></script>
</body>

# navbar.html에 새로 작성  ----------------------------
(templates > navbar.html) 생성
<body>
<!-- 네비게이션바   -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <a class="navbar-brand" href="{% url 'pybo:index' %}">Pybo</a>
            <button class="navbar-toggler ml-auto" type="button"
                    data-toggle="collapse"
                    data-target="#navbarNav"
                    aria-controls="navbarNav"
                    aria-expanded="false"
                    aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse flex-grow-0" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="#">로그인</a>
                    </li>
                </ul>
            </div>
    </nav>
</body>

"""3-02 페이징"""

# 페이지 나누기 테스트할 충분한 데이터 생성 ----------------

(cmd창)
mysite
python manage.py shell

from pybo.models import Question
from django.utils import timezone
for i in range(300):
  q = Question(subject='테스트데이터입니다.:[%03d]'%i, content='내용무', create_date=timezone.now())
  q.save()

Question.objects.all()

crtl+ z

python manage.py runserver


# Paginator --------------------------------------
(pybo > views.py) 수정
from django.core.paginator import Paginator

def index(request):
    page = request.GET.get('page','1')   # 페이지 , GET방식으로 호출
    question_list = Question.objects.order_by('-create_date')
    paginator = Paginator(question_list, 10)   # 페이지당 10개씩
    page_obj = paginator.get_page(page)     # 해당 페이지의 데이터만 조회, 페이지 객체 생성
    context = {'question_list': page_obj}
    return render(request, 'pybo/question_list.html', context)

# 한 페이지만 조회됨
http://127.0.0.1:8000/pybo/?page=4 # ?page= 뒤에 숫자 넣으면 해당 페이지 조회됨

# 템플릿에 페이징 적용, ----------------------
# question_list.html에서 페이지 처리 되도록 
(question_list.html) 추가
 테이블과 버튼 사이에 삽입

<!-- 페이징처리 START-->
    <ul class="pagination justify-content-center">
        <!-- 이전페이지 -->
        {% if question_list.has_previous %}     # 이전페이지가 있는지 체크
        <li class = "page-item">
            <a class="page-link" href = "?page={{ question_list.previous_page_number }}">이전</a>
        </li>
        {% else %}
        <li class = "page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="#">이전</a>
        </li>
        {% endif %}

        <!-- 페이지리스트 --> 
        {% for page_number in question_list.paginator.page_range %}    # 페이지리스트 루프
        {% if page_number == question_list.number %}      # 현재 페이지와 같은지 체크
        <li class="page-item active" aria-current="page">  
            <a class="page-link" href = "?page={{ page_number }}">{{ page_number }}</a>
        </li>
        {% else %}
        <li class="page-item">
            <a class = "page-link" href = "?page={{ page_number }}">{{ page_number }}</a>
        </li>
        {% endif %}
        {% endfor %}

        <!-- 다음페이지 -->
        {% if question_list.has_next %}          # 다음페이지가 있는지 체크
        <li class = "page-item">
            <a class="page-link" href = "?page={{ question_list.previous_page_number }}">다음</a>
        </li>
        {% else %}
        <li class = "page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="#">다음</a>
        </li>
        {% endif %}
    </ul>
    <!-- 페이징처리 END -->

# 실행해보면 
# 이동할 수 있는 페이지가 모두 표시됨

# 페이지 표시 제한 기능 구현 ---------------------------------------------
(question_list.html) 추가

{% for page_number in question_list.paginator.page_range %} # <--- 밑에 아래 추가
{% if page_number >= question_list.number|add:-5 and page_number <= question_list.number|add:5 %}

{% endif %} #<------- 밑에 아래 추가
{% endif %}

"""3-03 템플릿 필터"""

# 게시물 번호 오류 해결 ---------------------------------------------------

(pybo > templatetages) 폴더 생성
(templatetags > pybo_filter.py) 파일 생성
from django import template

register = template.Library()

@register.filter
def sub(value, arg):
    return value - arg

# 템플릿 필터 사용하기 ---------------------------------------
(question_list.html) 수정

{% extends 'base.html' %}
{% load pybo_filter %}  # <------ 추가
{% block content %}

      <td>{{ forloop.counter }}</td> # <--------------- 삭제
      <td>
            # 번호 = 전체건수 - 시작인덱스 - 현재인덱스 + 1 
        {{ question_list.paginator.count|sub:question_list.start_index|sub:forloop.counter0|add:1 }}
      </td>

# cmd창 껐다 켬

"""3-04 답변 갯수 표시"""

# 질문 목록에 답변갯수 표시

(question_list.html) 수정

    <a href = "{% url 'pybo:detail' question.id %}">{{ question.subject }}</a>  #<----- 이거 아래 삽입
    {% if question.answer_set.count > 0 %}  # 답변이 있는 경우 검사하고, 표시
    <span class="text-danger small mx-2">{{ question.answer_set.count }}</span>
    {% endif %}

"""3-05 로그인과 로그아웃"""

앱: django.contrib.auth

(cmd창)
mysite
django-admin startapp common   # common앱 생성

(config > settings.py) 추가
INSTALLED_APPS = [
    'common.apps.CommonConfig',    # common앱 등록
]

(config > urls.py) 수정

urlpatterns = [
    path('common/', include('common.urls')),   # common으로 시작하는 url이 common.urls.py을 참조
]

(common > urls.py) 생성
app_name = 'common'

urlpatterns = [
   
]


# 로그인 -----------------------
(tamplates > navbar.html) 추가

<a class="nav-link" href="{% url 'common:login' %}">로그인</a>  # 수정

(common >urls.py) url매핑 규칙 추가

from django.urls import path
from django.contrib.auth import views as auth_views

app_name = 'common'

urlpatterns = [
    path('login/', auth_views.LoginView.as_view(), name='login'),
]

# 로그인 템플릿 파일 작성 ----------------------
(common > urls.py ) 수정
    path('login/', auth_views.LoginView.as_view(template_name='common/login.html'), name='login'),


(templates > common) 폴더 생성
(templates > common > login.html) 생성
{% extends "base.html" %}
{% block content %}
<div class = "container my-3">
    <form method = "post" action="{% url 'common:login' %}">
        {% csrf_token %}
        {% include "form_errors.html" %}    # 오류 표시
        <div class="mb-3">
            <label for="username">사용자ID</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.value|default_if_none:'' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}


(templates > form_errors.html) 생성
<!-- 필드 오류와 넌필드 오류를 출력한다. -->
{% if form.errors %}
<div class="alert alert-danger">
    {% for field in form %}
    
    {% if field.errors %}   # 필드 오류: 오류로 값이 누락되었거나 필드 형식이 일치하지 않는 경우 발생
    <div>
        <strong>{{ field.label }}</strong>   # strong으로 강조
        {{ field.errors }}
    </div>
    {% endif %}
    {% endfor %}
    
    {% for error in form.non_field_errors %} #넌필드 오류: 필드의 결과와 무관하게 다른 이유로 발생하는 오류
    <div>
        <strong>{{ error }}</strong>
    </div>
    {% endfor %}
</div>
{% endif %}


(config > settings.py) 파일 수정
# 마지막줄
# 로그인 성공후 이동하는 URL
LOGIN_REDIRECT_URL = '/'


(config > urls.py) 추가   # /페이지에 대응하는 url 매핑 규칙 추가
from pybo import views

urlpatterns = [
  path('', views.index, name='index'),  # '/'에 해당하는 path
]

"""로그아웃"""

# 로그인 후에는 로그아웃 링크로 바뀌어야 함

(templates > navbar.html) 수정
<li class="nav-item">      # 로그인 되어 있으면 (로그아웃), 로그인 안되어있으면 로그인 표시
    {% if user.is_authenticated %}    # 현재 사용자가 로그인되어있는지 판별
    <a class="nav-link" href="{% url 'common:logout' %}">{{ user.username }} (로그아웃)</a>
    {% else %}
    <a class="nav-link" href="{% url 'common:login' %}">로그인</a>
    {% endif %}
</li>

(common > urls.py) 추가    # logout에 대응하는 url 매핑
urlpatterns = [
     path('logout/', auth_views.LogoutView.as_view(), name='logout'),  #<---- 추가
]


(config > settings.py) 추가     # 로그아웃시 이동하는 URL도 추가
LOGOUT_REDIRECT_URL = '/'

"""3-06 회원가입"""

# 회원가입 링크 추가

(templates > navbar.html) 추가    # (로그아웃) 로그인 밑에
            <li>
              {% if not user.is_authenticated %}
              <a class="nav-link" href="{% url 'common:signup' %}">회원가입</a>
              {% endif %}   # 회원가입은 로그아웃 상태에서만 보이도록 함
            </li>

(common > login.html) 추가
<div class = "container my-3">  #<----- 아래
    <div class="row">
        <div class="col-4">
            <h4>로그인</h4>
        </div>
        <div class="col-9 text-right">
            <span>또는 <a href = "{% url 'common:signup' %}"> 계정을 만드세요</a></span>
        </div>             
    </div>


# url 매핑규칙 추가
(common > urls.py) 추가 ---------------------------------------
from . import views
urlpatterns = [
  path('signup/', views.signup, name='signup'),
]

# 뷰함수 만들기 전에 계정생성시 사용할 userform을 작성
(common > forms.py) 생성 ----------------------------------------

from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User

# usercreationform 클래스를 상속하여 만들기
class UserForm(UserCreationForm):
    email = forms.EmailField(label="이메일")

    class Meta:
        model = User
        fields = ("username", "password1", "password2", "email")


# signup함수를 정의
(common > views.py) 추가 -----------------------------------

from django.contrib.auth import authenticate, login   #사용자 인증 , 로그인 담당
from django.shortcuts import render, redirect
from common.forms import UserForm


def signup(request):
    if request.method == "POST":
        form = UserForm(request.POST)    # POST요청인 경우 화면에 입력한 데이터로 사용자 생성
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')  # form.cleaned_data.get 입력값 개별적으로 얻고싶은 경우
            raw_password = form.cleaned_data.get('password1')
            user = authenticate(username=username, password=raw_password)  # 사용자 인증
            login(request, user)  # 로그인
            return redirect('index')
    else:
        form = UserForm()    #GET요청인 경우 회원가입 화면을 보여줌
    return render(request, 'common/signup.html', {'form': form})


(templates > common > signup.html) 작성 ----------------------------

{% extends "base.html" %}
{% block content %}
<div class="container my-3">
    <form method="post" action="{% url 'common:signup' %}">
        {% csrf_token %}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password1">비밀번호</label>
            <input type="password" class="form-control" name="password1" id="password1"
                   value="{{ form.password1.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password2">비밀번호 확인</label>
            <input type="password" class="form-control" name="password2" id="password2"
                   value="{{ form.password2.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="email">이메일</label>
            <input type="text" class="form-control" name="email" id="email"
                   value="{{ form.email.value|default_if_none:'' }}">
        </div>
        <button type="submit" class="btn btn-primary">생성하기</button>
    </form>
</div>
{% endblock %}

"""2-10 폼 (답변등록 추가)"""

# 답변 등록에도 댓글 
(pybo > forms.py) 추가
from pybo.models import Question, Answer

class AnswerForm(forms.ModelForm):
    class Meta:
        model = Answer
        fields = ['content']
        labels = {
            'content': '답변내용',
        }

(pybo > views.py) 추가/수정
from django.http import HttpResponseNotAllowed
from .forms import QuestionForm, AnswerForm

def answer_create(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    if request.method == "POST":              
        #답변등록은 POST방식만 사용되기 때문에 GET방식으로 요청할 경우에는 HttpResponseNotAllowed 오류 발생
        form = AnswerForm(request.POST)
        if form.is_valid():
            answer = form.save(commit=False)
            answer.create_date = timezone.now()
            answer.question = question
            answer.save()
            return redirect('pybo:detail', question_id=question.id)
    else:
        return HttpResponseNotAllowed('Only POST is possible.')
    context = {'question': question, 'form': form}
    return render(request, 'pybo/question_detail.html', context)

(pybo > question_detail.html) 추가

<form action="{% url 'pybo:answer_create' question.id %}" method="post" class="my-3">
        {% csrf_token %} # <------- 이 아래부터 추가
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->

"""3-07 모델 변경"""

# 게시판의 질문, 답변에 '글쓴이'항목 추가

(pybo > models.py) 추가
from django.contrib.auth.models import User)

class Question(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    (... 생략 ...)

# 껐다 켬
# 모델이 변경될때는 makemigration 필요
(cmd창)
mysite
python manage.py makemigrations
select an option: 1   # author들을 null값으로 입력하거나, 강제적으로 추가.
# 이미 작성된 글의 글쓴이를 무엇으로 저장할 것이냐
# null값 허용하려면 null=True로 하면 됨
author = models.ForeignKey(User, on_delete=models.CASCADE, null=True)
# 
exit
python manage.py migrate # 데이터베이스에 적용


(pybo > models.py) 추가 -----------------------------------
class Answer(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    (... 생략 ...)

# 다시 껐다 켬
(cmd창)
mysite
python manage.py makemigrations
select an option: 1
exit

# 질문과 답변 저장할 때도 author도 함께 저장해야 함
(pybo > views.py)
def answer_create(request, question_id):
    (... 생략 ...)
        if form.is_valid():
            answer = form.save(commit=False)  # commit=False 임시저장한 상태에
            answer.author = request.user  # author 속성에 로그인 계정 저장
            (... 생략 ...)

def question_create(request):
    (... 생략 ...)
        if form.is_valid():
            question = form.save(commit=False)
            question.author = request.user  # author 속성에 로그인 계정 저장

# 로그아웃 상태에서 질문/답변을 등록하면 ValueError 메시지가 나옴. user가 없기 때문

# 익명일 경우에 처리방법?
(pybo > views.py) 추가
from django.contrib.auth.decorators import login_required

@login_required(login_url='common:login') # <------ 삽입     로그인페이지를 띄움
def answer_create(request, question_id):

@login_required(login_url='common:login') # <------ 삽입
def question_create(request):


# hidden타입의 next항목 추가
(login.html)
      {% csrf_token %}
        <input type="hidden" name="next" value="{{ next }}">   # 로그인 성공 후 이동되는 URL


(question_detail.html) 추가

      <div class="mb-3">
            <label for="content" class="form-label">답변내용</label>
            <textarea {% if not user.is_authenticated %}disabled{% endif %}
              name="content" id="content" class="form-control" rows="10"></textarea>
      </div>


(views.py) 추가
def answer_create(request, question_id):
    if request.method == 'POST':
    else:
        return HttpResponseNotAllowed('Only POST is possible.') # <---- 삭제
        form = AnswerForm()  #<------ 삽입